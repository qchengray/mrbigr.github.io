<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Qian Cheng" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Tutorial - MRBIGR</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Tutorial";
        var mkdocs_page_input_path = "Tutorial.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> MRBIGR
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../QuickStart/">QuickStart</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Tutorial</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#genotype-data-based-analysis">Genotype data based analysis</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1format-conversion-of-genotypic-data">1.Format conversion of genotypic data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2quality-control-of-genotype-data">2.Quality control of genotype data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-fast-imputation-of-missing-genotype-values">3. Fast imputation of missing genotype values</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4-dimensionality-reduction-of-genotype-data-through-snp-clumping">4. Dimensionality reduction of genotype data through SNP clumping</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5calculation-of-kinship-matrix-from-genotype-data">5.Calculation of kinship matrix from genotype data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#6principle-component-analysis-from-genotype-data">6.Principle component analysis from genotype data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#7-t-sne-analysis-from-genotype-data">7. t-SNE analysis from genotype data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#8phylogenetic-analysis-from-genotype-data">8.Phylogenetic analysis from genotype data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#9functional-annotation-of-genotype-data">9.Functional annotation of genotype data</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#phenotype-data-based-analysis">Phenotype data based analysis</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1quality-control-of-phenotype-data">1.Quality control of phenotype data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2imputation-of-missing-phenotype-values">2.Imputation of missing phenotype values</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3scaling-and-normalization-of-phenotype-data">3.Scaling and normalization of phenotype data</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4correction-of-phenotype-data-base-on-population-structure">4.Correction of phenotype data base on population structure</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5merge-the-phenotype-values-from-different-environment">5.Merge the phenotype values from different environment</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gwas-and-qtl-related-analysis">GWAS and QTL related analysis</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1parallel-gwas">1.Parallel GWAS</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3annotation-of-qtl-regions">3.Annotation of QTL regions</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#6statistical-test-of-genes">6.Statistical test of genes</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#mendelian-randomization-analysis-of-multi-omics-data">Mendelian randomization analysis of multi-omics data</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1exposureoutcome-mode">1.Exposure/outcome Mode</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2pairwise-mode">2.Pairwise Mode</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3tf-mode">3.TF Mode</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#mr-based-network-construction-and-module-identification">MR-based network construction and module identification</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gene-ontology-analysis-of-network-modules">Gene ontology analysis of network modules</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#data-visualization">Data visualization</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1genotype-data-based-plot">1.Genotype data based plot</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2phenotype-data-based-plot">2.Phenotype data based plot</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3gwas-based-plot">3.GWAS based plot</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#4mr-data-based-plot">4.MR data based plot</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#5go-based-plot">5.GO based plot</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">MRBIGR</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Tutorial</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/CrazyHsu/MRBIGR/edit/master/docs/Tutorial.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="tutorial"><center>Tutorial</center></h1>
<p><center>Introduction of details and advanced usage of MRBIGR</center></p>
<hr />
<p>In this part, the implementation of each module/function/parameter in MRBIGR will be introduced in detail, and several real-data results will also be shown to help users better understand the functions of MRBIGR. </p>
<h2 id="genotype-data-based-analysis">Genotype data based analysis</h2>
<p>The genotype data analysis module takes plink-bed format genotype data as input, can be invoked through the subcommand <code>geno</code>, which includes 9 functions: <code>-convert</code>, <code>-qc</code>, <code>-imput</code>, <code>-clump</code>, <code>-kinship</code>, <code>-pca</code>, <code>-tsne</code>, <code>-tree</code> and <code>–anno</code>. <code>-convert</code> is used for genotype data format conversion; <code>-qc</code> is used for quality control of genotype data; <code>-imput</code> introduced several simple methods for fast imputation of genotype data; <code>-clump</code> is used to keep only one representative SNP per region of LD based on a clumping method, to reduce the dimensionality of the original genotype data; <code>-kinship</code> is used to calculate the kinship matrix from genotype data;<code>-pca</code> is used to perform principle component analysis from genotype data; <code>-tsne</code> is used to perform t-SNE analysis from genotype data; <code>-tree</code> is used to build a ML-tree from genotype data; <code>-anno</code> is used to annotate vcf-format genotype data.</p>
<h3 id="1format-conversion-of-genotypic-data">1.Format conversion of genotypic data</h3>
<p>MRBIGR supports the conversion of Hapmap/VCF format genotype data to plink-bed format, as well as the conversion of plink-bed format to VCF format. This function can be called through the parameter <code>-convert</code>. The command line is as follows:</p>
<pre><code class="language-py"># Hapmap to plink-bed  
MRBIGR.py geno -convert -hapmap test.hapmap -o test_hmp  
# VCF to plink-bed  
MRBIGR.py geno -convert -vcf test.vcf -o test_vcf  
# plink-bed to VCF  
MRBIGR.py geno –g geno –o geno.vcf  
</code></pre>
<p>The subcommand <code>geno</code> invokes the genotype data analysis module; parameter <code>–convert</code> calls the data format conversion function; <code>-hapmap</code> and <code>–vcf</code> are the correspond format file name; <code>-g</code> is the prefix of plink-bed format input data, <code>-o</code> is the name of output data.</p>
<h3 id="2quality-control-of-genotype-data">2.Quality control of genotype data</h3>
<p>The raw genotype data may contain SNPs with low values of MAF (minor allele frequency), high level of missing rate, as well as samples with extreme high missing rate. These data should be filtered before downstream analysis. The <code>geno</code> module provides a QC-based genotype data filter function which can be called through parameter <code>–qc</code>. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py geno -qc -g geno -o geno_qc -maf 0.05 -mis 0.2 -mind 0.2  
</code></pre>
<p>The subcommand geno invokes the genotype analysis module; parameter <code>–qc</code> calls the quality control function; <code>–g</code> is the plink-bed format input genotype data; <code>-o</code> is the output genotype data prefix; <code>-maf</code> is the MAF for a SNP to be kept; <code>-mis</code> is the maximum proportion of missing values for a SNP to be kept; -mind is the maximum proportion of missing values for a sample to be kept. The parameters <code>–maf</code>, <code>-mis</code> and <code>–mind</code> have default values and are not mandatory.</p>
<h3 id="3-fast-imputation-of-missing-genotype-values">3. Fast imputation of missing genotype values</h3>
<p>MRBIGR provides several fast and simple methods to impute the missing values in the input genotype data, either <code>“random”</code> (sampling according to allele frequencies), <code>“mean0”</code> (rounded mean), <code>“mean2”</code> (rounded mean to 2 decimal places), <code>“mode”</code> (most frequent call). It should be noted that these methods are just for fast imputation of test dataset, more accurate imputation of genotype data should be performed using other professional imputation tools such as Beagle. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py geno -imput -method mode -g geno_qc -o geno  
</code></pre>
<p>The subcommand <code>geno</code> invokes the genotype analysis module; parameter <code>–imput</code> calls the genotype imputation function; <code>-method</code> is the imputation method; <code>–g</code> is the plink-bed format input genotype data, <code>-o</code> is the output genotype data prefix (<font color=blue>suffix_imput</font> will be added automatically for the output files).</p>
<h3 id="4-dimensionality-reduction-of-genotype-data-through-snp-clumping">4. Dimensionality reduction of genotype data through SNP clumping</h3>
<p>SNP clumping is used to keep only one representative SNP per region of LD, which can be used to reduce dimensionality of the genotype data. This method is proposed in R package bigsnpr, it is similar to the LD-based SNP pruning method in PLINK, but SNP clumping has the advantage of only the SNP with the highest MAF is kept in a LD region and more genetic variation can be kept. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py geno -clump -g geno_qc -o geno  
</code></pre>
<p>The subcommand <code>geno</code> invokes the genotype analysis module; parameter <code>–clump</code> calls the genotype clumping function to keep only one representative SNP per region of LD; <code>–g</code> is the plink-bed format input genotype data, <code>-o</code> is the output genotype data prefix (<font color=blue>suffix _clump</font> will be added automatically for the output files).</p>
<h3 id="5calculation-of-kinship-matrix-from-genotype-data">5.Calculation of kinship matrix from genotype data</h3>
<p>Pairwise kinship coefficients calculation is used as a measurement of genetic similarity between individuals. MRBIGR can generate a kinship/relatedness matrix by the below command:</p>
<pre><code class="language-py">MRBIGR.py geno -kinship -g geno_clump -o kinship  
</code></pre>
<p>The subcommand <code>geno</code> invokes the genotype analysis module; parameter <code>–kinship</code> calls the kinship calculation function; <code>–g</code> is the plink-bed format input genotype data, <code>-o</code> is the output file prefix. The output file <font color=blue>kinship.cXX.txt</font> could be found in a directory named output.</p>
<h3 id="6principle-component-analysis-from-genotype-data">6.Principle component analysis from genotype data</h3>
<p>Principal components analysis (PCA) is commonly applied to population structure inference and dimension reduction of the data. Top PCs calculated from the genotype data can reflect population structure among the sample individuals. MRBIGR can perform PCA analysis by the below command:</p>
<pre><code class="language-py">MRBIGR.py geno -pca -g geno_clump -o geno -dim 10  
</code></pre>
<p>The subcommand <code>geno</code> invokes the genotype analysis module; parameter <code>–pca</code> calls the PCA analysis function; <code>–g</code> is the plink-bed format input genotype data, <code>-o</code> is the output file prefix, <code>-dim</code> is the dimensionality or PCs for the output data, with a default value 10. Then, a CSV format output file named <font color=blue>geno_pc.csv</font> would be generated.</p>
<h3 id="7-t-sne-analysis-from-genotype-data">7. t-SNE analysis from genotype data</h3>
<p>t-SNE (t-Distributed Stochastic Neighbor Embedding) is a machine learning algorithm for dimensional reduction. As a nonlinear dimensional reduction algorithm, t-SNE performs better than PCA, and is suitable for visualization of population structure. MRBIGR first use PCA to reduce the data to 50 dimensions, and then use t-SNE algorithm to further reduced the data to 2 or 3 dimensions. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py geno -tsne -g geno_clump -o geno -dim 3  
</code></pre>
<p>The subcommand <code>geno</code> invokes the genotype analysis module; parameter <code>–tsne</code> calls the t-SNE analysis function; <code>–g</code> is the plink-bed format input genotype data, <code>-o</code> is the output file prefix, <code>-dim</code> is the dimensionality for the output data, usually 2 or 3, with a default value 3. Then, a CSV format output file named <font color=blue>geno_tsne.csv</font> would be generated.</p>
<h3 id="8phylogenetic-analysis-from-genotype-data">8.Phylogenetic analysis from genotype data</h3>
<p>MRBIGR introduces a one-step phylogenetic analysis function from genotype data, which facilitate the visualization of relatedness of individuals and population structure. A nwk format maximum likelihood (ML) tree can be generated follow this command:</p>
<pre><code class="language-py">MRBIGR.py geno -tree -g geno_clump -o geno_tree  
</code></pre>
<p>The subcommand <code>geno</code> invokes the genotype analysis module; parameter <code>–tree</code> calls the phylogenetic analysis function; <code>–g</code> is the plink-bed format input genotype data, <code>-o</code> is the output file prefix. Then, a nwk format output file named <font color=blue>geno_tree.tree.nwk</font>  and some other related files <font color=blue>ggeno_tree.*</font>  would be generated.</p>
<h3 id="9functional-annotation-of-genotype-data">9.Functional annotation of genotype data</h3>
<p>This function in MRBIGR is relied on ANNOVAR, an efficient software tool to utilize update-to-date information to functionally annotate genetic variants. Only <code>vcf-format</code> genotype data is supported as input, plink-bed format genotype data should be converted to VCF format using the <code>–convert</code> function. If annotation is performed for the first time, an annotation database should be built by adding the parameters <code>–gtf</code> and <code>–fa</code>. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py geno -anno -vcf test.vcf -o testvcf_anno -db ZmB73 -dbdir ./ref -gtf ./ref/Zea_mays.Zm-B73-REFERENCE-NAM-5.0.51.chr.gtf -fa ./ref/Zea_mays.Zm-B73-REFERENCE-NAM-5.0.dna.toplevel.fa  
</code></pre>
<p>The subcommand <code>geno</code> invokes the genotype analysis module; parameter <code>–anno</code> calls the annotation function; <code>–vcf</code> is the vcf-format input genotype data, <code>-o</code> is the output file prefix; <code>-db</code> is the output database name; <code>-dbdir</code> is the output database directory; <code>-fa</code> is the reference genome sequences file in FASTA format; <code>-gtf</code> is the reference gene annotation file in GTF format. Then, MRBIGR would generate an annotation database and perform functional annotate for genetic variants automatically. The output annotation result files include <font color=blue>testvcf_anno.ZmB73_multianno.vcf, testvcf_anno.ZmB73_multianno.bed, and testvcf_anno.ZmB73_largeEffect.bed.</font> If the annotation database has been built before, the parameters <code>–gtf</code> and <code>–fa</code> are no longer need, and the parameters <code>–db</code> and <code>–dbdir</code> are the input database name and database directory, respectively. In this case, the command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py geno -anno -vcf test2.vcf -o testvcf2_anno -db ZmB73 -dbdir ./ref -gtf ./ref/Zea_mays.Zm-B73-REFERENCE-NAM-5.0.51.chr.gtf  
</code></pre>
<h2 id="phenotype-data-based-analysis">Phenotype data based analysis</h2>
<p>The phenotype data analysis module takes a CSV format phenotype file with the first column and the first row should be the names of samples and traits as input, can be invoked through the subcommand <code>pheno</code>, which includes 5 functions: <code>-qc</code>, <code>-imput</code>, <code>-scale</code>, <code>-correct</code>, and <code>–merge</code>. <code>-qc</code> is used for quality control of phenotype data; <code>-imput</code> is used for imputation of missing values in phenotype data; <code>-scale</code> is used for data scaling, normalization, standardization or transformation of phenotype data; <code>-correct</code> is used for population structure based phenotype data correction; <code>-merge</code> is used to merge a trait from different environment or years using either the methods of mean values, BLUP or BLUE.</p>
<h3 id="1quality-control-of-phenotype-data">1.Quality control of phenotype data</h3>
<p>Quality control of the original phenotype data include transposition of the original phenotype matrix if needed, removal of outlier data points based on z-score or boxplot methods, filtering traits with high level of missing rate and low average values. In this function, either of the parameters <code>–tr</code>, <code>–rout</code>, <code>-mis</code> and <code>–val</code> is optional. If you want to perform quality control use all the default parameters, the command line looks like this</p>
<pre><code class="language-py">MRBIGR.py pheno –qc -p pheno.csv -o pheno_qc -rout -mis -val  
</code></pre>
<p>The subcommand <code>pheno</code> invokes the phenotype analysis module; parameter <code>–qc</code> calls the quality control function; <code>-p</code> is the input phenotype matrix; <code>-o</code> is the prefix of output file; <code>-mis</code> is the missing rate cutoff with default value 0.5; <code>-val</code> is the small value cutoff with default value 0.1; <code>-rout</code> means outlier removal of phenotypic values with the default method z-score. If you want to perform quality control use personalized parameters, the command line could be as follows:</p>
<pre><code class="language-py"># transposition of the original phenotype matrix  
MRBIGR.py pheno –qc -tr pheno.csv -o pheno_tr  
# reset missing rate cutoff, skip small value filter and outlier removal  
MRBIGR.py pheno –qc -p pheno.csv -o pheno_qc -mis 0.1  
# skip small value filter and set outlier removal method to boxplot  
MRBIGR.py pheno –qc -p pheno.csv -o pheno_qc -rout boxplot –mis  
</code></pre>
<h3 id="2imputation-of-missing-phenotype-values">2.Imputation of missing phenotype values</h3>
<p>There are three different phenotype imputation methods provided by MRBIGR: <code>mean</code>, <code>median</code>, <code>most_frequent</code>. The missing phenotype values in input file should be defined as NA, and the command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py pheno –-imput -p pheno_qc.phe.csv -o pheno_imput –method most_frequent  
</code></pre>
<p>The subcommand <code>pheno</code> invokes the phenotype analysis module; parameter <code>–imput</code> calls the phenotype imputation function; <code>-p</code> is the input phenotype matrix; <code>-o</code> is the prefix of output file; <code>-method</code> is the imputation method. After this step, a phenotype file named <font color=blue>pheno_imput.phe.csv</font> with no missing value would be generated.</p>
<h3 id="3scaling-and-normalization-of-phenotype-data">3.Scaling and normalization of phenotype data</h3>
<p>MRBIGR provides multiple commonly used phenotype data scaling and normalization methods, such as logarithmization, z-score standarlization, box-cox normalization, normal quantile normalization. These scaling and normalization methods are applicable to different types of phenotype data, like agronomic traits, transcripts expression data, metabolites intensity data. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py pheno –scale -p pheno_imput.phe.csv –o pheno_norm –boxcox -minmax
</code></pre>
<p>The subcommand <code>pheno</code> invokes the phenotype analysis module; parameter <code>–scale</code> calls the phenotype scaling/normalization/standardization/transformation function; <code>-p</code> is the input phenotype matrix; <code>-o</code> is the prefix of output file; <code>-boxcox</code> and <code>–minmax</code> means use both Box-Cox and Min-Max methods to transform the data. Box-Cox transformation is used to transform each trait to meet normality assumptions, a lambda is calculated per trait and used to transform each trait, while Min-Max scaling is used to scale the values to 0-1. Other optional methods are <code>-log2，-log10，-ln，-qqnorm，-zscore</code>，and <code>-robust</code>.</p>
<h3 id="4correction-of-phenotype-data-base-on-population-structure">4.Correction of phenotype data base on population structure</h3>
<p>Since population structure may lead to phenotype data distributed in different levels, in some cases, correction of phenotype values to the same level based on population structure may help downstream analysis. The <code>–correct</code> function in MRBIGR use a PCA file, which can be generated through genotype data, to perform phenotype data correction. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py pheno -correct -p pheno_imput.phe.csv -o pheno_correct -pca geno_pca.csv 
</code></pre>
<p>The subcommand <code>pheno</code> invokes the phenotype analysis module; parameter <code>–correct</code> calls the phenotype correct function; <code>-p</code> is the input phenotype matrix; <code>-o</code> is the output file prefix; <code>-pca</code> is the PCA result file generated by genotype data through the command <code>geno –pca</code>. </p>
<h3 id="5merge-the-phenotype-values-from-different-environment">5.Merge the phenotype values from different environment</h3>
<p>Phenotype data form different environment or years need to be merged before downstream analysis, commonly used phenotype data merge algorithms are mean-value, BLUP (best linear unbiased prediction) and BLUE (best linear unbiased estimation). MRBIGR provides all three methods for this purpose, which can be called and selected from parameters <code>–merge</code> and <code>–mm</code>. It is noted that only one trait is accepted in an input file. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py pheno -merge -p trait1.csv -o trait1_blup -mm blup  
</code></pre>
<p>The subcommand <code>pheno</code> invokes the phenotype analysis module; parameter <code>–merge</code> calls the phenotype merge function; <code>-p</code> is the input phenotype matrix for a trait in CSV format;<code>-o</code> is the prefix of output file; <code>-mm</code> is the merge method. After this step, a phenotype file named <font color=blue>trait1_blup.phe.csv</font> with BLUP merged phenotypic values would be generated.</p>
<h2 id="gwas-and-qtl-related-analysis">GWAS and QTL related analysis</h2>
<p>The GWAS and QTL related analysis module can be utilized for GWAS, QTL detection and annotation, as well as peak or gene based haplotype analysis, this module can be invoked through the subcommand gwas, which includes 6 functions: -gwas, -qtl, -anno, -visual, -peaktest, and –genetest. –gwas is used to perform GWAS, -qtl is used to detect QTLs from GWAS results, -anno is used for annotation of QTL regions, -visual is used for the visualization of GWAS results, -peaktest is used for peak based haplotype test, -genetest is used for gene based haplotype test.</p>
<h3 id="1parallel-gwas">1.Parallel GWAS</h3>
<p>MRBIGR support parallel GWAS for multiple traits. Take the processed plink-bed format genotype data and CSV format phenotype data as inputs, GWAS can be performed through the below command:</p>
<pre><code class="language-py">MRBIGR.py gwas -gwas -model lmm -thread 12 -g geno_qc -p pheno_norm.csv 
``` 
The subcommand gwas invokes the GWAS and QTL analysis module; parameter –gwas calls the GWAS function which utilizes GEMMA to perform GWAS; -model is the model to fit, with either linear mixed model (lmm) or linear model (lm) as option; -thread is the thread number to run the command; -g is the plink-bed format input genotype data; -p is the CSV format phenotype data. After this step, an output directory would be generated with the GWAS result files named trait_name.assoc.txt in it. 
### 2.Parallel QTL detection based on GWAS results
MRBIGR introduces the clumped method implemented in PLINK v1.9 to automatically detect and optimize QTLs based on the original GWAS results. In detail, a stricter P-value threshold –p1 is set to uncover the significantly associated SNPs; then,  for each significantly associated SNP, if the other SNPs within a 500 kb distance have P-values smaller than the second looser P-value threshold –p2, and have r2 values greater than 0.2 with the index SNP, as well as the number of such SNPs surpass the SNP number threshold –p2n, then the region is regarded as a QTL; finally, all overlapping QTLs are merged to generate the final QTL set, while the SNP with the smallest P-value in a QTL is defined as a lead SNP.The command line is as follows:
```py
MRBIGR.py gwas -qtl -g geno_qc -thread 6 -i output -o qtl_output -p1 1e-5 -p2 1e-3 -p2n 5  
</code></pre>
<p>The subcommand gwas invokes the GWAS and QTL analysis module; parameter –qtl calls the QTL detection function; -thread is the thread number to run the command; -i is the GWAS result directory; -o is the output file prefix; -p1 is the significance threshold for index SNPs used to determine QTLs; -p2 is the secondary significance threshold for clumped SNPs used to determine the reliability of QTLs; -p2n is secondary significance SNP number in a QTL. After this step, an output file named qtl_output.qtl_res.csv would be generated.</p>
<h3 id="3annotation-of-qtl-regions">3.Annotation of QTL regions</h3>
<p>The QTL result file could be annotated use a four columns gene annotation file in TSV format, which looks like this:</p>
<pre><code class="language-shell">1.geneid  aliased position    function  
2.Zm00001eb015280 Zm00001eb015280 1:52319290-52320913:+   Zm00001eb015280  
3.Zm00001eb000610 Zm00001eb000610 1:2555438-2555822:+     Zm00001eb000610  
4.Zm00001eb033210 Zm00001eb033210 1:184900367-184903962:+ Zm00001eb033210
```  
This file could be generated from a standard GTF format gene annotation file through the follow command:
```shell
grep -v '#' input.gtf |awk '{if($3==&quot;gene&quot;){print $0}}' |sed 's/ /\t/g'|sed 's/&quot;//g'|sed 's/;//g'|awk '{print $10&quot;\t&quot;$10&quot;\t&quot;$1&quot;:&quot;$4&quot;-&quot;$5&quot;:&quot;$7&quot;\t&quot;$10}'|sed '1igeneid\taliased\tposition\tfunction' &gt;gene.anno.tsv
</code></pre>
<p>Then, take this file as input, QTL annotation could be performed use follow the command:</p>
<pre><code class="language-py">MRBIGR.py gwas -anno -q qtl_output.qtl_res.csv -a gene.anno.tsv -o anno_output
```  
The subcommand gwas invokes the GWAS and QTL analysis module; parameter –anno calls the QTL annotation function; -q is the input QTL result file for annotation file; -o is the prefix of output file. After this step, an output file named anno_output.qtl_anno.csv would be generate.
### 4.Visualization of GWAS results
Manhattan-plots and QQ-plots can be generated for the visualization purpose of the GWAS results. The command line is as follows: 
```py
MRBIGR.py gwas -anno -q qtl_output.qtl_res.csv -a gene.anno.tsv -o anno_output  
</code></pre>
<p>or</p>
<pre><code class="language-py">python MRBIGR.py gwas -visual -i output -o vis_output -multi -q qtl_output.qtl_res.csv -thread 12
```  
The subcommand gwas invokes the GWAS and QTL analysis module; parameter –visual calls the visualization function; -i is the GWAS result directory; -o is the output directory prefix; -multi is optional, with a multi-trait Manhattan-plot would be generate when set; -q is the input QTL result file, it only need to be set when -multi is set; -thread is the thread number to run the command.
### 5.Statistical test of lead SNP
A simple approach to establish the relationship of phenotype distribution and QTL haplotype type is to use genotype of the lead SNP to represent the haplotype type of the QTL region, then, phenotype values distribution under different genotype of the lead SNP could be displayed, and student’s test could be performed. This simple statistical test can be performed in MRBIGR through the command below:
```py
python MRBIGR.py gwas -peaktest -o peaktest_output –p pheno.csv -g geno_output_clump -q qtl_output.qtl_res.csv  
</code></pre>
<p>The subcommand gwas invokes the GWAS and QTL analysis module; parameter –peaktest calls the peak test function; -o is the directory of output files; -p is the input phenotype data; -g is the input genotype data; -q is the input QTL result file. Then, genotype information of each sample and phenotype distribution plot would be generated in the output directory.</p>
<h3 id="6statistical-test-of-genes">6.Statistical test of genes</h3>
<p>Another approach to establish the relationship of phenotype distribution and QTL haplotype is to test the phenotype distribution and haplotype type for each gene in the QTL, to discover potential casual gene and variants. For a QTL region, MRBIGR uses large effect variants in each gene to build gene haplotypes, and perform gene based haplotype test. Welch’s test was used for a two-group haplotype test and a Tukey’s test was used for a multiple group haplotype test as described in Yano et al, 2016. The command line is as follows:</p>
<pre><code class="language-py">python MRBIGR.py gwas -genetest -f1 anno_output.qtl_anno.csv -f2 testvcf_anno.ZmB73_multianno.bed -vcf test.vcf –p pheno.csv -o genetest_output  
</code></pre>
<p>The subcommand gwas invokes the GWAS and QTL analysis module; parameter –genetest calls the gene test function; -f1 is the input QTL annotation file generated by gwas –anno command; -f2 is the input genotype annotation file generated by geno –anno command; -p is the input phenotype file; -o is the directory of output files. Then, related gene haplotype information of each sample and phenotype distribution plot would be generated in the output directory.</p>
<h2 id="mendelian-randomization-analysis-of-multi-omics-data">Mendelian randomization analysis of multi-omics data</h2>
<p>The Mendelian randomization analysis module can be utilized for perform Mendelian randomization analysis between different omics data, this module can be invoked through the subcommand <code>mr</code>, which includes 3 modes according to parameters. The first mode provides input omics data through the <code>-exposure</code> and <code>-outcome</code> parameters, and performs Mendelian randomization analysis between <code>-exposure</code> data and <code>-outcome</code> data; the second mode provides transcriptome expression data through the <code>-gene_exp</code> parameter, and perform Mendelian randomization analysis between gene pairs through the <code>-pairwise</code> parameter; the third mode provides transcriptome expression data through the <code>-gene_exp</code> parameter, the <code>-tf</code> parameter provides the annotation information of the transcription factor, and <code>-target</code> provides the transcription factor target gene annotation information, and then perform Mendelian randomization analysis between transcription factors and target genes. There are two calculation models for Mendelian randomization, linear model and mixed linear model, respectively, specified by the parameters <code>-lm</code> and <code>-mlm</code>.</p>
<h3 id="1exposureoutcome-mode">1.Exposure/outcome Mode</h3>
<p>The first mode uses the <code>-exposure</code> parameter to specify the exposure data required by the Mendelian randomization model, <code>-outcome</code> provides the outcome data required by the Mendelian randomization model, and <code>-qtl</code> provides the genetic variation of the exposure data, then Mendelian randomization analysis can be performed through the below command:</p>
<pre><code class="language-py">MRBIGR.py mr -g geno_qc -exposure exposure.csv -qtl exposure_qtl.csv -outcome outcome.csv -mlm -thread 12 -o mr_out  
</code></pre>
<p>The subcommand <code>mr</code> invokes the Mendelian randomization analysis module; parameter <code>-exposure</code> is the CSV format exposure data; <code>-outcome</code> is the CSV format outcome data; <code>-qtl</code> is the CSV format exposure QTL data; <code>-thread</code> is the thread number to run the command; <code>-g</code> is the plink-bed format input genotype data; <code>-mlm</code> represents perform Mendelian randomization analysis through mixed linear model; <code>-o</code> is the prefix of output file. After this step, a MR result file named <font color=blue>mr_out.MR.csv</font> would be generated.</p>
<h3 id="2pairwise-mode">2.Pairwise Mode</h3>
<p>The second mode uses the <code>-gene_exp</code> parameter to specify the population gene expression data, <code>-qtl</code> specifies the genetic variation that affects gene expression, and <code>-pairwise</code> indicates to perform Mendelian randomization analysis between all pairs of genes in the population gene expression data, pairwise genes Mendelian randomization analysis can be performed through the below command:</p>
<pre><code class="language-py">MRBIGR.py mr -g geno_qc -gene_exp gene_exp.csv -pairwise -mlm -qtl gene_qtl.csv -thread 12  -o pairwise_mr_out  
</code></pre>
<p>The subcommand <code>mr</code> invokes the Mendelian randomization analysis module; parameter <code>-gene_exp</code> is the CSV format population gene expression data; <code>-qtl</code> is the CSV format gene QTL data; <code>-thread</code> is the thread number to run the command; <code>-g</code> is the plink-bed format input genotype data; <code>-mlm</code> represents perform Mendelian randomization analysis through mixed linear model; <code>-o</code> is the prefix of output file. After this step, a MR result file named <font color=blue>pairwise_mr_out.MR.csv</font> would be generated.</p>
<h3 id="3tf-mode">3.TF Mode</h3>
<p>The third mode uses the <code>-gene_exp</code> parameter to specify the population expression data while using the <code>-tf</code> and <code>-target</code> parameters to specify the transcription factor and their target genes, respectively, and then perform Mendelian randomization analysis between the transcription factors and the target genes. The regulatory relationship between transcription factors and target genes can be divided into direct and indirect regulatory relationships. In detail, when the genomic distance between a transcription factor and its target gene is &lt; 500 kb, the relationship between them is defined as direct relationship, while the regulatory relationship between the transcription factor and remaining target genes are defined as indirect regulation. The <code>-type</code> parameter is used to specify the regulatory relationship between transcription factors and target genes in Mendelian randomization analysis. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py mr -g geno_qc -gene_exp gene_exp.csv -tf tf_genefunc.txt -target target_genefunc.txt -mlm -qtl tf_qtl.csv -type direct -threads 12 -o tf_mr_out  
</code></pre>
<p>The subcommand <code>mr</code> invokes the Mendelian randomization analysis module; parameter <code>-gene_exp</code> is the CSV format population gene expression data; <code>-qtl</code> is the CSV format transcription factor QTL data; <code>-tf</code> is the transcription factor annotation file; <code>-target</code> is the annotation files for genes targeted by transcription factors; <code>-thread</code> is the thread number to run the command; <code>-g</code> is the plink-bed format input genotype data; <code>-mlm</code> represents perform Mendelian randomization analysis through mixed linear model; <code>-type</code> is the regulatory relationship between transcription factors and target genes, with either direct (perform Mendelian randomization analysis transcription factors and directly regulated targeted genes) or all (perform Mendelian randomization analysis between transcription factors and all targeted genes) as option;<code>-o</code> is the prefix of output file. After this step, a MR result file named <font color=blue>tf_mr_out.MR.csv</font> would be generated.</br></p>
<p><img alt="#5A9AB9" src="../img/tips%403x.png" /><strong>Tips</strong>: The transcription factor annotation file and the annotation files for genes targeted by 
transcription factors could be annotated use a four columns gene annotation file in TSV format, 
which looks like this:  </p>
<pre><code class="language-bash">geneid  aliased position    function  
Zm00001eb015280 Zm00001eb015280 1:52319290-52320913:+   Zm00001eb015280  
Zm00001eb000610 Zm00001eb000610 1:2555438-2555822:+     Zm00001eb000610  
Zm00001eb033210 Zm00001eb033210 1:184900367-184903962:+ Zm00001eb033210  
</code></pre>
<h2 id="mr-based-network-construction-and-module-identification">MR-based network construction and module identification</h2>
<p>In MRBIGR, the weight of MR effects between gene pairs are used to construct the MR-based network and ClusterONE algorithm is used to identify modules for the constructed network. The MR-based network analysis command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py net -mr pairwise_mr_out.MR.csv -plot -o net_out  
</code></pre>
<p>The subcommand <code>net</code> invokes the Mendelian randomization based network analysis module; parameter <code>-mr</code> is the CSV format Mendelian randomization analysis data; <code>-plot</code> represents plot network for each identified network module ;<code>-o</code> is the prefix of output file. After this step, network edgelist file <font color=blue>net_out.edge_list</font>, ClusterONE software result <font color=blue>net_out.clusterone.result.csv</font>, network module plot <font color=blue>net_out.module*.pdf</font> and final network module file <font color=blue>net_out.module.csv</font> would be generated.</p>
<h2 id="gene-ontology-analysis-of-network-modules">Gene ontology analysis of network modules</h2>
<p>Gene ontology analysis of the MR-based network modules is helpful to find modules with biological significance. The enrichGO function in R package clusterProfiler is used to perform GO enrichment analysis on each module based on gene ontology annotation, and rich graphics (e.g., <code>dotplot, barplot, cnetplot, heatplot, emapplot, upsetplot</code>) could be chose for the visualization of the enrichment results. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py go -gene_lists net_out.module.csv -go_anno go_anno.txt -gene_info gene_anno.txt -plot_type barplot,dotplot -o go_out  
</code></pre>
<p>The subcommand <code>go</code> invokes the gene ontology enrichment analysis module; parameter <code>-gene_lists</code> is the CSV format network module data; <code>-go</code> is the Tabular format gene ontology annotation of each gene data; <code>-gene_info</code> is the Tabular format gene annotation data; <code>-plot_type</code> is visualization type of enrichment results; <code>-o</code> is the prefix of output file. After this step, gene ontology enrichment analysis <font color=blue>result go_out.GO.csv</font>, visualized results of functional enrichment results <font color=blue>go_out.BP.dotplot.pdf</font> , <font color=blue>go_out.MF.dotplot.pdf</font>  and <font color=blue>go_out.CC.dotplot.pdf</font> , <font color=blue>go_out.BP.barplot.pdf</font> , <font color=blue>go_out.MF.barplot.pdf</font>  and <font color=blue>go_out.CC.barplot.pdf</font>  would be generated.</p>
<p><img alt="#5A9AB9" src="../img/tips%403x.png" /><strong>Tips</strong>: The gene ontology annotation information of each gene could be annotated use a two 
columns annotation file in TSV format, which looks like this: </p>
<pre><code class="language-bash">Zm00001d018305  GO:0051649  
Zm00001d018305  GO:0003677  
Zm00001d003209  GO:0005886  
Zm00001d003209  GO:0044238  
</code></pre>
<p>The gene annotation information of each gene could by annotated use a five columns annotation file 
in TSV format, which looks like this:  </p>
<pre><code class="language-bash">gene_id chr start   end stard   annotation  
Zm00001d027230  1   44289   49837   +   Mitochondrial transcription termination factor family protein  
Zm00001d027231  1   50877   55716   -   OSJNBa0093O08.6 protein  
Zm00001d027232  1   92299   95134   -   Zm00001d027232  
Zm00001d027234  1   118683  119739  -   Zm00001d027234 
</code></pre>
<h2 id="data-visualization">Data visualization</h2>
<p>The data visualization module in MRBIGR provides a collection of plot functions for the visualization of genotype, phenotype, GWAS, Mendelian randomization, network, and GO analysis results. This module can be invoked through the subcommand plot. The parameter <code>-i</code> is used to specify the data file needed for plotting, <code>-plot_type</code> specifies the plot type, the options include <code>manhattan, qqplot, SNPdensity, hist, boxplot, scatterplot_ps, barplot, dotplot, forestplot</code>, and <code>scatterplot_mr</code>.</p>
<h3 id="1genotype-data-based-plot">1.Genotype data based plot</h3>
<p>The genotype data based plot includes SNP density plot (<code>SNPdensity</code>) and scatterplot of population (<code>scatter_ps</code>). SNP density plot is used to demonstrate the distribution of the SNP across the genome. The command line is as follows: </p>
<pre><code class="language-py">MRBIGR.py plot -i example.snp_inofo.txt -plot_type SNPdensity -o plot_out  
</code></pre>
<p><img alt="#5A9AB9" src="../img/tips%403x.png" /><strong>Tips</strong>: The SNP information file could be annotated use a three columns file in TSV format, which 
looks like this: </p>
<pre><code class="language-bash">rs  chr ps  
chr10.s_109149  10  109149  
chr10.s_109277  10  109277  
chr10.s_109475  10  109475  
chr10.s_109511  10  109511  
</code></pre>
<p>The first column represents the SNP id, the second column represents the chromosome of the SNP, and the third column represents the position of the SNP.
The population scatterplot takes a PCA or t-SNE result file as input to visualize the population structure. The population information of each individual can be specified by the -group parameter, which is used to assign individuals to populations with different colors. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py plot -i example.PCA.csv -plot_type scatter_ps -group example.ps_info.csv -o plot_out  
</code></pre>
<p>The population structure file could be annotated use a three columns file in CSV format, which looks like this:</p>
<pre><code class="language-bash">RIL,PC1,PC2  
GEMS58,38.88 ,-59.69   
CML415,-30.07 ,1.74   
SI273,52.52 ,11.30   
CIMBL135,-38.45 ,9.53   
</code></pre>
<p>The first column represents the sample id, the second column represents first principal component data of each inbred line, and the third column represents second principal component data of each inbred line.
The group file could be annotated use a two columns file in CSV format, which looks like this:</p>
<pre><code class="language-bash">RIL,subpop  
GEMS58,NSS  
CML415,TST  
SI273,NSS  
CIMBL135,TST  
</code></pre>
<p>The first column represents the sample identifier, the second column represents the population information of each sample.</p>
<h3 id="2phenotype-data-based-plot">2.Phenotype data based plot</h3>
<p>The phenotype data based plot includes histogram (<code>hist</code>) and boxplot (<code>boxplot</code>), which are used to demonstrate the distribution of phenotype data. Boxplot can not only show the overall distribution of phenotypes, but also the phenotype distribution of different groups, when the -group parameter is specified. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py plot -i example.phe.csv -plot_type hist -o plot_out  
MRBIGR.py plot -i example.phe.csv -plot_type boxplot -group example.group.csv -o plot_out  
</code></pre>
<p>The phenotype file could be annotated use a two columns file in CSV format, which looks like this:</p>
<pre><code class="language-bash">RIL,1st  
CAU1,0.8234  
CAU2,0.7121  
CAU3,0.6665  
CAU4,0.8731 
</code></pre>
<p>The first column represents the sample identifier, the second column represents the phenotype data of each sample.
The group file could be annotated use a two columns file in CSV format, which looks like this:</p>
<pre><code class="language-bash">RIL,haplotype  
CAU1,A  
CAU2,A  
CAU3,A  
CAU4,T
</code></pre>
<p>The first column represents the sample ID, the second column represents the group of each sample, which can be haplotype type or populations information.</p>
<h3 id="3gwas-based-plot">3.GWAS based plot</h3>
<p>The GWAS based plot includes manhattan plot (<code>manhattan</code>) and QQ plot (<code>qqplot</code>), which is used to demonstrate GWAS result. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py plot -i example.gwas.txt -plot_type manhattan -o plot_out  
MRBIGR.py plot -i example.gwas.txt -plot_type qqplot -o plot_out 
</code></pre>
<p><img alt="#5A9AB9" src="../img/tips%403x.png" /><strong>Tips</strong>: The GWAS result file could be annotated use a four columns file in TSV format, which looks
like this:  </p>
<pre><code class="language-bash">rs  chr ps  p_wald  
1_1922301   1   1922301 9.121183e-03  
1_1928050   1   1928050 1.795902e-03  
1_2521954   1   2521954 7.200593e-03  
1_2522874   1   2522874 6.791745e-03  
</code></pre>
<p>The first column represents the ID of SNPs, the second column represents the chromosome of SNPs, and the third column represents the position of SNPs, the fourth column represents the GWAS P-value of SNPs.</p>
<h3 id="4mr-data-based-plot">4.MR data based plot</h3>
<p>The MR based plot includes forest plot (<code>forestplot</code>) and scatter plot (<code>scatter_mr</code>). The forest plot is used to display the effect between each exposure and outcome traits, and can specify the order of the outcome traits in the forest plot through the order file, so as to compare the effects of different exposures on the outcome traits. It can be used to compare the influence of different exposures under a small number of outcome traits. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py plot -i mr_out.MR.csv -plot_type forestplot -order order.txt -o plot_out  
</code></pre>
<p><img alt="#5A9AB9" src="../img/tips%403x.png" /><strong>Tips</strong>: The MR file is generated by mr subcommand. The order file is a column file that list 
outcome traits, which looks like this: </br></p>
<pre><code class="language-bash">Ear length  
Ear leaf width  
Kernel width  
Ear diameter  
</code></pre>
<p>The scatter plot is used to display the Mendelian randomized p-value between exposure and outcome, and group the outcome through the group file. It can be used to show the impact of exposure on the outcome traits under a large number of outcome traits. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py plot -i mr_out.MR.csv -plot_type scatter_mr -group anno.txt -o plot_out  
</code></pre>
<p><img alt="#5A9AB9" src="../img/tips%403x.png" /><strong>Tips</strong>: The group file of outcome traits could be annotated use a two columns annotation file in 
CSV format, which looks like this:  </p>
<pre><code class="language-bash">id,group  
Zm00001d028748,1  
Zm00001d025572,10  
Zm00001d005932,2  
Zm00001d042777,3  
</code></pre>
<p>The first column represents the outcome trait, and the second column represents the category corresponding to the outcome trait, which can be the chromosome where the gene is located, the type of metabolite, etc.</p>
<h3 id="5go-based-plot">5.GO based plot</h3>
<p>The GO based plot includes bar plot (<code>barplot</code>) and dot plot (<code>dotplot</code>). It depicts the enrichment scores (e.g. P-values) and gene count or ratio in plot. The command line is as follows:</p>
<pre><code class="language-py">MRBIGR.py plot -i example.GO.csv -plot_type barplot -o plot_out  
MRBIGR.py plot -i example.GO.csv -plot_type dotplot -o plot_out 
</code></pre>
<p><img alt="#5A9AB9" src="../img/tips%403x.png" /><strong>Tips</strong>:The GO enrichment result file could be annotated use a ten columns file in CSV format,
which looks like this:  </p>
<pre><code class="language-bash">ONTOLOGY,ID,Description,GeneRatio,BgRatio,pvalue,p.adjust,qvalue,geneID,Count  
MF,GO:0003729,mRNA binding,5/82,371/37229, 1.393e-3,0.033,0.026,Zm00001d044979/Zm00001d049442/Zm00001d005350,5 
</code></pre>
<p>The first column represents the ontology domains, including BP, MF and CC, the second column represents the ontology id, the third column represents the description of ontology id, the fourth column represents the ratio of genes containing ontology id in the gene list to the total genes in the gene list, the fifth column represents the ratio of genes containing ontology id in whole genome to the total genes in whole genome, the sixth column represents the P value of GO enrichment analysis, the seventh and eighth columns represents the corrected P value of GO enrichment analysis, it can be same when the GO enrichment result file is user-customized, the ninth column represents the gene id of genes containing ontology id, the tenth represents the count of genes containing ontology id.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../QuickStart/" class="btn btn-neutral float-left" title="QuickStart"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../about/" class="btn btn-neutral float-right" title="About">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/CrazyHsu/MRBIGR/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../QuickStart/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../about/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
